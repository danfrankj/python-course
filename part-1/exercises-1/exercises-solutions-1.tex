\documentclass{article}
\newcommand{\assgnnum}{1}
\newcommand{\assigndate}{January 10}

\usepackage{amsmath}
\usepackage{fullpage}
\usepackage{amssymb}
%\usepackage{bbm}
\usepackage{fancyhdr}
\usepackage{booktabs}
%\usepackage{paralist}
\usepackage{graphicx}
\usepackage[pdftex,colorlinks=true, urlcolor = blue]{hyperref}
\usepackage{../../arbenson-math}

\oddsidemargin 0in \evensidemargin 0in
\topmargin -0.5in \headheight 0.25in \headsep 0.25in
\textwidth 6.5in \textheight 9in
\parskip 6pt \parindent 0in \footskip 20pt

% set the header up
\fancyhead{}
\fancyhead[L]{CME193: In-class exercises solutions \assgnnum}
\fancyhead[R]{\assigndate}
%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand\headrulewidth{0.4pt}
\setlength\headheight{15pt}


\newcommand{\p}{\ensuremath{\mathbf{P}}}
\renewcommand{\Pr}[1]{\ensuremath{\p \left \{ #1 \right \}}}
\newcommand{\nti}{\ensuremath{n \to \infty}}
\newcommand{\I}{\ensuremath{\operatorname{I}}}
\newcommand{\One}[1]{\ensuremath{\mathbbm{1}_{\left \{ #1 \right \}}}}
\newcommand{\E}{\ensuremath{\mathbf{E}}}
\newcommand{\Ex}[2][]{\ensuremath{\E_{#1} \left[ #2 \right]}}
\newcommand{\var}{\ensuremath{\operatorname{Var}}}
\newcommand{\cov}{\ensuremath{\operatorname{Cov}}}
\newcommand{\F}{\ensuremath{\mathcal{F}}}
\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\C}{\ensuremath{\mathbb{C}}}
\newcommand{\NormRV}[2]{\ensuremath{\operatorname{N}\left(#1, #2\right)}}
\newcommand{\BetaRV}[2]{\ensuremath{\operatorname{Beta}\left(#1, #2\right)}}
\newcommand{\argmax}{\operatornamewithlimits{argmax}}
\newcommand{\x}{\mathbf{x}}
\newcommand{\A}{\mathbf{A}}
\newcommand{\bb}{\mathbf{b}}


\newcounter{points}
\setcounter{points}{0}

\newcommand\setpoints[1]{\addtocounter{points}{#1}(#1 points)}
\newcommand\printpoints{Total number of points: \thepoints}

\newcommand{\eqD}{\ensuremath{\overset{\mathcal{D}}{=}}}

\setlength{\parindent}{0in}

\begin{document}

\pagestyle{fancy}
%\vspace*{15pt}

This document is available at \url{http://stanford.edu/~arbenson/cme193/exercises/exercises-solutions-1.pdf}.


\begin{enumerate}
\item \textbf{True/False} \\
State whether the following statements are \texttt{True} or \texttt{False} as it would be evaluated in Python (i.e., how it was described in lecture).  Assume that the variable \texttt{x} has a boolean value of \texttt{False} and that the variable \texttt{y} has the value $10$.

\begin{enumerate}
\item
\begin{lstlisting}
x and (8 < y < 12)
\end{lstlisting}
\texttt{False}.  Note: Due to operator precedence, you do not actually need the parentheses here.
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{1}
\item 
\begin{lstlisting}
'CME ' + '193' == 'cme193'
\end{lstlisting}
\texttt{False}
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{2}
\item 
\begin{lstlisting}
(y != 12 - 2) or x
\end{lstlisting}
\texttt{False}.  Note: Due to operator precedence, you do not actually need the parentheses here.
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{3}
\item 
\begin{lstlisting}
'py' * 2 + 'thonic' == 'pypythonic'
\end{lstlisting}
\texttt{True}
\end{enumerate}

\item \textbf{Arithmetic} \\
State what $x$ is after each of the following scripts is executed.

\begin{enumerate}
\item \lstinputlisting{code/arith1.py}

x is 1
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{1}
\item \lstinputlisting{code/arith2.py}
x is the string ``pythonpypypythonpypy"
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{2}
\item \lstinputlisting{code/arith3.py}
x is 3.
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{3}
\item \lstinputlisting{code/arith4.py}
This code actually produces an error because we cannot add an integer to a string.
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{4}
\item \lstinputlisting{code/arith5.py}
x is the string ``hello2".  The \texttt{str()} function casts the integer 2 as the string ``2".
\end{enumerate}


\item \textbf{Functions and Flow} \\
For each of the following Python scripts, state what gets printed.

\begin{enumerate}
\item \lstinputlisting{code/fnf_a.py}
\texttt{30}
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{1}
\item \lstinputlisting{code/fnf_b.py}
\texttt{4}.  Note: this function is calculating an approximation to $\log_2x$.
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{2}
\item \lstinputlisting{code/fnf_c.py}
$i$ and $j$ both start at $0$.  The following table shows how the values change at the end of each iteration of the while loop.
\begin{center}
\begin{tabular}{l l}
\toprule
i & j \\
\midrule
0 & 0 \\
1 & 0 \\
2 & 1 \\
3 & 3 \\
4 & 6 \\
7 &  12 \\
10 &  21 \\
13 &  20 \\
16 &  19 \\
\bottomrule
\end{tabular}
\end{center}
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{3}
\item The \texttt{elif} statement combines the concepts of an \texttt{else} and an \texttt{if} statement.  It follows an \texttt{if} statement.  If the \texttt{if} statement is false, then the \texttt{elif} statement is evaluated.  If the \texttt{elif} statement is true, that code block executes. \\

\lstinputlisting{code/fnf_d.py}

``world! hello"
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{4}
\item \lstinputlisting{code/fnf_e.py}
32.  \texttt{func\_e(7, 7)} recursively calls \texttt{func\_e(6, 8)}, which returns \texttt{max(a, b)}.  Python allows for function definitions within functions, which we encounter with the function call \texttt{func\_e(7, -7)}.
\end{enumerate}

\item \textbf{Applications} \\
Consider the following snippet of Python code: \\

\lstinputlisting{code/deriv1.py}

\begin{enumerate}
\item What gets printed? \\

22
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{1}
\item What is this function doing? \\

This is a (forward) finite difference method for estimating the derivative of the polynomial $x^3 + 3x + 3$.
\end{enumerate}

\begin{enumerate}
\setcounter{enumii}{2}
\item Describe some abstractions for this function.  What can be provided as parameters? \\

\texttt{step} and \texttt{point1} can easily be provided as parameters.  We can also make the function an input, since we do not want to only be able to estimate derivatives for $x^3 + 3x + 3$.  Instead of estimating the derivative at one point, we could estimate the derivative at several points.
\end{enumerate}

Using concepts from the next lecture, here is a much more powerful function:

\begin{center}
\begin{tabular}{c}
\lstinputlisting{code/deriv2.py}
\end{tabular}
\end{center}

Note: The \texttt{lambda} keyword lets us define functions without a particular name.  These are called anonymous functions.  They are convenient for passing parameters.  We will learn about anonymous functions in the second lecture.

\end{enumerate}
%\printpoints.
\end{document} 
